<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://www.jiazhenjiang.com/</id><title>小木屋</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-09-24T16:03:58+08:00</updated> <author> <name>ZhenJiang.Jia</name> <uri>https://www.jiazhenjiang.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://www.jiazhenjiang.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://www.jiazhenjiang.com/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 ZhenJiang.Jia </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Redis哨兵挂了，Redis 还能正常工作吗？</title><link href="https://www.jiazhenjiang.com/posts/Redis-%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86-redis-%E8%BF%98%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%90%97/" rel="alternate" type="text/html" title="Redis哨兵挂了，Redis 还能正常工作吗？" /><published>2021-09-16T15:50:00+08:00</published> <updated>2021-09-16T15:50:00+08:00</updated> <id>https://www.jiazhenjiang.com/posts/Redis-%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86-redis-%E8%BF%98%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%90%97/</id> <content src="https://www.jiazhenjiang.com/posts/Redis-%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86-redis-%E8%BF%98%E8%83%BD%E6%AD%A3%E5%B8%B8%E5%B7%A5%E4%BD%9C%E5%90%97/" /> <author> <name>ZhenJiang.Jia</name> </author> <category term="数据库" /> <category term="Redis" /> <summary> redis 主挂掉了，怎么将请求转移到从上去，如果从是多个，从是怎么进行选举的呢？ 那么就要看我们今天的主角了，redis哨兵，redis哨兵能够帮助我们自动的完成选主和故障转移操作。 redis哨兵都干了什么 redis哨兵是一个运行的特殊的redis进程，他主要有三个使命： 监控 选主 通知 监控的是什么 哨兵主要是监听主库和从库是否存活，怎么进行监控？ 哨兵会定期的给从库发送PING命令，如果从库没有在设定的时间内回复哨兵，那么就会认为从库下线了。哨兵也会定期的给主库发送PING命令进行通信，如果主库也没有在设定的时间内回复哨兵，那么就会认为主库也“下线了”。【注意我这里只是为了说明下监控的方式，真正判断的主库下线不是这样的】。 看图说话： 可以看到图中redis-2 slave 是灰色，表示已经down掉了，此时并没有正常返回给哨兵响应，所... </summary> </entry> <entry><title>HTTP与TCP的keep-alive的区别</title><link href="https://www.jiazhenjiang.com/posts/HTTP%E4%B8%8ETCP%E7%9A%84keep-alive%E7%9A%84%E5%8C%BA%E5%88%AB/" rel="alternate" type="text/html" title="HTTP与TCP的keep-alive的区别" /><published>2021-09-16T15:20:00+08:00</published> <updated>2021-09-24T16:03:29+08:00</updated> <id>https://www.jiazhenjiang.com/posts/HTTP%E4%B8%8ETCP%E7%9A%84keep-alive%E7%9A%84%E5%8C%BA%E5%88%AB/</id> <content src="https://www.jiazhenjiang.com/posts/HTTP%E4%B8%8ETCP%E7%9A%84keep-alive%E7%9A%84%E5%8C%BA%E5%88%AB/" /> <author> <name>ZhenJiang.Jia</name> </author> <category term="网络" /> <category term="HTTP" /> <summary> TCP 的 Keepalive 和 HTTP 的 Keep-Alive 是一个东西吗？ 事实上，这两个完全是两样不同东西，实现的层面也不同： HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接； TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制； 接下来，分别说说它们。 HTTP 的 Keep-Alive HTTP 协议采用的是「请求-应答」的模式，也就是客户端发起了请求，服务端才会返回响应，一来一回这样子。 请求-应答 由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务端收到后就返回响应，至此「请求-应答」的模式就完成了，随后就会释放 TCP ... </summary> </entry> <entry><title>JMeter之beanshell断言实例</title><link href="https://www.jiazhenjiang.com/posts/jmeter%E4%B9%8Bbeanshell%E6%96%AD%E8%A8%80%E5%AE%9E%E4%BE%8B/" rel="alternate" type="text/html" title="JMeter之beanshell断言实例" /><published>2021-09-15T11:36:00+08:00</published> <updated>2021-09-15T11:36:00+08:00</updated> <id>https://www.jiazhenjiang.com/posts/jmeter%E4%B9%8Bbeanshell%E6%96%AD%E8%A8%80%E5%AE%9E%E4%BE%8B/</id> <content src="https://www.jiazhenjiang.com/posts/jmeter%E4%B9%8Bbeanshell%E6%96%AD%E8%A8%80%E5%AE%9E%E4%BE%8B/" /> <author> <name>ZhenJiang.Jia</name> </author> <category term="JMeter" /> <category term="基础" /> <summary> 1.首先储存一个接口的响应结果，比如在http请求的后面添加beanshell后置处理器(BeanShell PostProcessor)来储存http请求的响应结果： import org.json.*; //获取上一个请求的返回值 String response = prev.getResponseDataAsString(); //将返回值转换为json JSONObject responseJson = new JSONObject(response); //获取responseMessage String message = responseJson.getString("responseMessage"); log.info("message的值：" + message); //使用vars.put()方法储存变量message vars.put("message"... </summary> </entry> <entry><title>Jmeter 中 CSV 如何参数化测试数据并实现自动断言</title><link href="https://www.jiazhenjiang.com/posts/Jmeter-%E4%B8%AD-CSV-%E5%A6%82%E4%BD%95%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%96%AD%E8%A8%80/" rel="alternate" type="text/html" title="Jmeter 中 CSV 如何参数化测试数据并实现自动断言" /><published>2021-09-09T13:21:00+08:00</published> <updated>2021-09-09T13:21:00+08:00</updated> <id>https://www.jiazhenjiang.com/posts/Jmeter-%E4%B8%AD-CSV-%E5%A6%82%E4%BD%95%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%96%AD%E8%A8%80/</id> <content src="https://www.jiazhenjiang.com/posts/Jmeter-%E4%B8%AD-CSV-%E5%A6%82%E4%BD%95%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E6%96%AD%E8%A8%80/" /> <author> <name>ZhenJiang.Jia</name> </author> <category term="JMeter" /> <category term="基础" /> <summary> 当我们使用Jmeter工具进行接口测试，可利用CSV Data Set Config配置元件，对测试数据进行参数化，循环读取csv文档中每一行测试用例数据，来实现接口自动化。此种情况下，很多测试工程师只会人工地查看响应结果来判断用例是否通过。 其实我们同样可利用CSV Data Set Config来帮助我们实现自动断言。 思路：将每一条用例的预期结果一并保存在csv文档中，循环读取文档中的期望结果，来跟实际运行的结果进行一致性判断，高效实现接口自动化。 示例： 1、整理测试数据及预期结果的CSV文档 比如当前要去测试一个注册接口，先来分析下注册传入哪些参数，有包括手机号码mobile_phone、密码Pwd、用户类型type、注册名reg_name；分析注册返回结果并取响应结果中参数code、msg实现断言。 将注册中每条用例需要传入的这4个参数数据，以及需要断言... </summary> </entry> <entry><title>Jmeter之JSON提取器应用</title><link href="https://www.jiazhenjiang.com/posts/Jmeter%E4%B9%8BJSON%E6%8F%90%E5%8F%96%E5%99%A8%E5%BA%94%E7%94%A8/" rel="alternate" type="text/html" title="Jmeter之JSON提取器应用" /><published>2021-09-09T11:32:00+08:00</published> <updated>2021-09-09T11:32:00+08:00</updated> <id>https://www.jiazhenjiang.com/posts/Jmeter%E4%B9%8BJSON%E6%8F%90%E5%8F%96%E5%99%A8%E5%BA%94%E7%94%A8/</id> <content src="https://www.jiazhenjiang.com/posts/Jmeter%E4%B9%8BJSON%E6%8F%90%E5%8F%96%E5%99%A8%E5%BA%94%E7%94%A8/" /> <author> <name>ZhenJiang.Jia</name> </author> <category term="JMeter" /> <category term="基础" /> <summary> 在接口测试中有一个这样的场景：登录之后，需要进行昵称修改，怎么实现？ 首先我们分别看下登录、昵称修改的接口说明： 以上业务中补充一点，昵称修改，还需要添加请求头Authorization传登录获取的token值。 分析：登录之后的响应结果中会返回用户id、token信息; 而更新昵称需要传参member_id、且需要请求头传token；也就是我们要想办法从“登录”的响应结果中获取到id、token信息，再去传给“更新昵称”请求。因为返回数据格式是json，所以我们用JSON提取器来实现。用正则表达式提取器也可以，大家可参见我之前写的文章。 一、json提取器设置多个变量获取多个数据 1、先添加好登录请求，运行下查看登录的响应结果 调整下查看结果方式，可较清晰看到响应结果中的id、token信息 JSON path表达式怎么写？例如我要获取id，可写$.d... </summary> </entry> </feed>
